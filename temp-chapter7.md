# 第七章 进一步的讨论

在这一节，我们通过实例对CodeBin的效果进行了评估，并指出了其局限性；并且，我们从安全的角度从新审视了CodeBin，为弥补其局限性提供了一些可行的、进一步的研究方向。

## 7.1 局限性

### 7.1.1 自定义预处理宏(Custom Preprocessor Macros)

OpenSSL重度依赖于自定义的预处理宏来进行不同环境下的代码实现和性能优化。这一技巧与普通的函数功能类似，通过小段的代码来对一系列的参数进行操作，但通过宏来实现。OpenSSL中的许多功能都有多种实现方式，一部分使用了带有参数的宏来定义，而另一部分则使用了普通的函数来实现。这些宏会在构建的过程中，根据编译器、平台架构和操作系统的类型，替换成不同的二进制实现。

代码清单4展示了在OpenSSL中，通过定义宏ROTATE，来对循环移位进行的四种不同的实现。这四种相似的实现方式，形成了4个不同的调用流图模式(call graph pattern)，并导致了OpenSSL中des_encrypt1这一函数，产生了多于10种的不同版本。每个版本，都为特定的环境做了优化，并且会根据传递给编译器的参数，选择性地置入可执行文件。

[LISTING 4: 在OpenSSL中ROTATE的不同实现]

在OpenSSL中，这一技巧的使用，会显著影响CodeBin在完全自动化的设置中的性能。如果没有使用和二进制文件编译时相同的预处理宏，并使用CodeBin的源代码预处理工具来分析的话，上文所提到的不同实现往往会因局部ACG搜索(partial ACG searches)的不匹配，而导致调用流图结构和函数属性产生显著不同。当使用了相同的预处理宏参数时，匹配能力会有显著的提升，正如表格2所示。

### 7.1.2 孤儿函数(Orphan Functions)

Codebin对于重用函数的另一个辨别难点，是由函数动态调用导致的。在C语言中，函数指针便用于实现这样的动态调用。被调用的函数，只有在运行时才能确定。因此，在代码的解析和编译过程中都无法据此作出更多(用于分析的)假设。尽管，复杂的内部数据流分析技术在一定程度上有助于在编译期确定动态调用的对象，但大多数情况下，动态分析还是应对此类情况的首选[31]。


